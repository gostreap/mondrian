\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\begin{document}
	\title{Mondrian \\
			\large Projet de programmation fonctionnelle}
	
	\author{Tristan François et Alexandre Moine}
	\maketitle
	
\section{Compilation}
Le projet nécessite \verb|dune| pour être compilé correctement:\\
\verb|$ dune build bin/mondrian.exe|

Pour exécuter le projet, lancer:\\
\verb|$ dune exe bin/mondrian.exe|

\section{Menu}
Le premier menu permet de choisir entre le jeu d'origine (avec deux couleurs possibles pour les rectangles) ou le jeu étendu (avec trois couleurs possibles par rectangles).
Une fois le mode choisit, l'utilisateur peut choisir la profondeur maximale de la partition de l'espace qui va être générée.

\section{Problème à 3 couleurs}

Nous avons implémenté une généralisation du problème avec 3 couleurs. Dans cette variante :
\begin{itemize}
	\item Une ligne est rouge si il y a plus de rectangle rouge adjacent que de rectangle vert et plus que de rectangle bleu.
	\item Une ligne est verte si il y a plus de rectangle vert adjacent que de rectangle rouge et plus que de rectangle bleu.
	\item Une ligne est bleu si il y a plus de rectangle bleu adjacent que de rectangle rouge et plus que de rectangle vert.
\end{itemize}
	
\section{Génération de formule}


\section{Tseitin}
Nous générons une forme normale conjonctive (FNC) représentant le problème pour 2 couleurs, mais nous n'y sommes pas arrivés pour 3 couleurs. Nous avons donc implémenté l'algorithme de Tseitin (amélioré par Plaisted-Greenbaum) permettant de transformer n'importe quelle formule en FNC en temps linéaire.
Cette méthode a néanmoins le défaut de générer une formule comportant beaucoup de variables. À titre d'exemple, une formule faisant intervenir 25 rectangles à l'origine compte plus de 2500 variables à la sortie de l'algorithme (en fait, une nouvelle variable a (presque) été ajoutée pour chaque sous-formule de la formule d'origine).

Ce travail se trouve dans le fichier \verb|lib/tseitin.ml|.

\section{SAT Solver}
Le SAT Solver fourni pour le projet a clairement montré ses limites avec autant de variables, nous avons donc tenté de l'améliorer. L'idée est que l'algorithme de Tseitin produit énormément de 2-clauses (des clauses ne contenant que 2 variables). Par exemple, une formule générée par l'algorithme de Tseitin avec 2000 clauses en contient presque 1500.\\
De plus, on connait des algorithmes très efficaces pour résoudre le problème 2-SAT (en temps linéaire). Nous avons donc modifié le SAT Solver fourni pour qu'il essaye des affectations de valeurs tant qu'il y a des clauses avec plus de 2 variables, puis on résout le problème en utilisant un algorithme plus efficace (en $n*log(n)$ pour $n$ le nombre de variables).
\end{document}